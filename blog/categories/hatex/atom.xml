<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: HaTeX | λaughedelic's blog]]></title>
  <link href="http://laughedelic.github.com/blog/categories/hatex/atom.xml" rel="self"/>
  <link href="http://laughedelic.github.com/"/>
  <updated>2013-02-15T01:57:24+01:00</updated>
  <id>http://laughedelic.github.com/</id>
  <author>
    <name><![CDATA[laughedelic]]></name>
    <email><![CDATA[laughedelic@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[HaTeXExtension @ GitHub]]></title>
    <link href="http://laughedelic.github.com/blog/2011/11/01/hatexextension-at-github/"/>
    <updated>2011-11-01T12:40:00+01:00</updated>
    <id>http://laughedelic.github.com/blog/2011/11/01/hatexextension-at-github</id>
    <content type="html"><![CDATA[<p><em>(репост из <a href="http://laughedelic.tumblr.com/post/12173307363">tumblr</a>)</em></p>

<p>Итак, официальный анонс ")
Теперь у моего прожекта HaTeXExtension есть своя клёвая страничка на github-pages с мажорным адресом.</p>

<p><a href="http://laughedelic.github.com/HaTeXExtension">http://laughedelic.github.com/HaTeXExtension</a></p>

<p>Плюс там онлайн документация, которую я писал пол-ночи "/ Ну и сам код на гитхабе.</p>

<p>Кстати, автор <a href="http://dhelta.net/hprojects/HaTeX/">HaTeX</a> (Daniel Díaz) нашёл мою репу на гитхабе раньше, чем я успел всё доделать. При этом он уже перенёс пару фишек в основную версию и дал на меня ссылку в общий mailing-list. Я довольный же! <code>^__^</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HaTeXExtension + TH: Спаривание операторов ]]></title>
    <link href="http://laughedelic.github.com/blog/2011/10/30/template-haskell-in-hatexextension-2/"/>
    <updated>2011-10-30T02:41:00+01:00</updated>
    <id>http://laughedelic.github.com/blog/2011/10/30/template-haskell-in-hatexextension-2</id>
    <content type="html"><![CDATA[<p><em>(репост из <a href="http://laughedelic.tumblr.com/post/12091298710/hatexextension-th">tumblr</a>)</em></p>

<p>Продолжаю серию дополнений HaTeXExtension с использованием Template Haskell. В этом посте будет пример шаблона с рекурсивным сплайсингом/цитированием.</p>

<p>Кроме отдельных операторов-синонимов, о которых шла речь в предыдущем посте, я определяю иногда их спаренный вариант - это удобно, потому что иногда хочется написать их один за другим, а поотдельности нельзя (каждому из них нужен второй аргумент), а если написать их слитно, то два операторных символа подряд с синтаксической точки зрения - просто новое имя оператора. Вот пример того, что есть сейчас:</p>

<p>``` haskell</p>

<pre><code>a ¸ b = a ◇ comma ◇ b
a ⎕ b = a ◇ space ◇ b
a ¸⎕ b = a ¸ "" ⎕ b
</code></pre>

<p>```</p>

<p>Хорошо, от первых двух деклараций мы избавились изменив шаблон <code>defTeXCommand</code>. Теперь я хочу сделать шаблон, который будет брать пары операторных символов и генерировать объявление их спаренного варианта. Гм, пошёл делать и понял, что можно брать не пары а списки, чтобы можно было сплавлять сколько угодно операторов.</p>

<!-- more -->


<p>(...прошло некоторое время...)</p>

<p>В общем я подумал, потыкался, и не придумал, как сделать этот шаблон, чтобы передавать ему сами операторы, потому что непонятно, как имея лишь функцию, получить её имя.. Подумаю ещё потом, а пока сделаю шаблон, который будет брать имена операторов в виде строк и делать своё не гигиеничное спаривание ")</p>

<p>``` haskell</p>

<pre><code>defFusedOperators :: [String]   -- ^ strings with operator names
                   →  Q [Dec]   -- ^ top-level declaration
defFusedOperators list = sequence
    [ concat ops ^= body ops | ops ← (map words list) ]
    where 
        body, fuse :: [String] → Q Exp
        body ops = [| λ a b → a ◇ $(fuse ops) ◇ b |]

        fuse   []   = [| "" |]
        fuse (x:xs) = [| $(dyn x) "" "" ◇ $(fuse xs) |]
</code></pre>

<p>```</p>

<p>Чтобы не писать <code>[["¸","⎕","≤"], ["¸","…","¸"]]</code>, что практически не читабельно, мы будем писать так: <code>["¸ ⎕ ≤", "¸ … ¸"]</code>, а в шаблоне эти строки просто разбиваются по пробелам на списки отдельных имён.</p>

<p>Итак, разберём это определение. Шаблон берёт такой вот список сгруппированных имён операторов, пробегает по нему и создаёт объявления операторов со склеенными именами (<code>concat ops</code>). Тело каждого такого оператора выглядит как лямбда <code>λ a b → a ◇ $(fuse ops) ◇ b</code>, то есть оператор, берёт два аргумента и вклеивает между ними спаренные операторы.</p>

<p>Самое интересное - это <code>fuse</code>. Она берёт список операторов (строк с их именами), и делает рекурсивную подстановку. Напомню, что <code>dyn x</code> - это процитированный оператор, мы его сплайсим, то есть вклеиваем и даём ему два пустых аргумента (у него ведь тип <code>LaTeX → LaTeX → LaTeX</code>), чтобы получить просто значение типа <code>LaTeX</code>. А дальше мы соединяем (<code>◇</code>) это с вклеенным результатом рекурсивного вызова <code>$(fuse xs)</code>. Когда же операторы заканчиваются, <code>fuse []</code> возвращает процитированную пустую строку (на самом деле это значение <code>TeXEmpty</code>).</p>

<p>Обычная рекурсивная функция, по своей сути ничем не примечательна, но интересно это цитирование и расцитирование, которое делается по ходу дела. Нужно внимательно следить, чтобы не процитировать два раза или не сделать дважды сплайсинг - <strong>баланс сил сохраняй, юный хаскеллер</strong> ")</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Использование Template Haskell в HaTeXExtension]]></title>
    <link href="http://laughedelic.github.com/blog/2011/10/30/template-haskell-in-hatexextension-1/"/>
    <updated>2011-10-30T01:12:00+02:00</updated>
    <id>http://laughedelic.github.com/blog/2011/10/30/template-haskell-in-hatexextension-1</id>
    <content type="html"><![CDATA[<p><em>(репост из <a href="http://laughedelic.tumblr.com/post/12087955995/template-haskell-hatexextension">tumblr</a>)</em></p>

<h2>Вступление</h2>

<p>За последние дни я много экспериментировал с Template Haskell и узнал много интересных вещей. Я по прежнему многое ещё не понимаю, но со многими вопросами я разобрался и хочу об этом тут написать. Сразу оговорюсь, что мои ответы скорее всего являются следствием того, что я не умею пока готовить TH, или я просто изобретаю самокаты.</p>

<p>Итак, на этой неделе я уже написал два поста о <a href="http://laughedelic.github.com/blog/2011/10/26/hatex-with-unicode/">HaTeX-3</a> и <a href="http://laughedelic.github.com/blog/2011/10/27/template-haskell-note/">Template Haskell</a>. В последнем посте я ставил вопрос о генерации объявлений с помощью TH и непонятной мне невозможности замены имени объявляемого объекта в цитированном коде. (Ну и оборот завернул, это у меня после написания эссе по философии)</p>

<p>Сегодня я немного поразбирался с квазицитированием (<a href="http://www.haskell.org/haskellwiki/Quasiquotation">Quasiquotation</a>, далее коротко QQ) - ещё одним расширением Haskell'а, на базе TH. Рекомендую почитать статью по ссылке и разобрать несложный пример - на нём многое становится понятно. Поначалу я недоумевал - ну парсеры, ну с другим синтаксисом, ну и что… Но сегодня я наконец-то осознал в чём истинная сила QQ и обязательно напишу об этом на следующей неделе. У меня уже есть пара идей для реализации с помощью QQ и в том числе для HaTeX.</p>

<h2>Постановка задачи</h2>

<p>Задача на самом деле остаётся та же, что и в предыдущем посте про TH. Только теперь я переформулирую её в контексте моих экспериментов с HaTeX. Поскольку каких-то TeX'овских команд мне не хватало в HaTeX'е, я решил написать для него небольшое дополнение. Итак, в моём модуле HaTeXExtension была куча объявлений вида</p>

<p>``` haskell</p>

<pre><code>space :: LaTeX
space = " \\quad "

leq :: LaTeX
leq = " \\leq "
</code></pre>

<p>```</p>

<p>и т.п. С переходом на новую версию HaTeX'а, я переделал их таким образом:</p>

<p>``` haskell</p>

<pre><code>space :: LaTeX
space = TeXComm "quad" []

leq :: LaTeX
leq = TeXComm "leq" []
</code></pre>

<p>```</p>

<p>Это конечно не бог весть какой код, но когда таких функций 10 или 20, мне он всё же кажется достаточно скучным и я нашёл в этом повод для себя попробовать использовать Template Haskell. То есть я хочу генерировать такие объявления автоматически по имени команды и функции. Так что теперь этот код выглядит у меня следующим образом:</p>

<p>``` haskell</p>

<pre><code>defTeXCommand "space" "quad"

defTeXCommand "" "leq"     -- имя функции и команды одинаковые
</code></pre>

<p>```</p>

<p>Повторюсь, что задача высосана из пальца, но её можно воспринимать как простой пример.</p>

<!-- more -->


<h2>Решение</h2>

<p>Собственно бо'льшую часть моего подхода я описал в предыдущем посте. Сначала я конечно сделал всё вручную, настрадался, а потом уже задумался о том, как это можно улучшить. Шаблоны должны быть в отдельном модуле, таковы правила TH:</p>

<p>``` haskell</p>

<pre><code>module HaTeXExtension.Meta where

…

defTeXCommand :: String   -- ^ function name
               → String   -- ^ TeX command name
               → Q [Dec]  -- ^ top-level declaration
defTeXCommand  ""  comm = defTeXCommand comm comm
defTeXCommand name comm = sequence
    [ name ^:: [t| LaTeX |]
    , name ^= [| TeXComm comm [] |]
    ]
</code></pre>

<p>```</p>

<p>Вроде бы выглядит достаточно просто и понятно. Объявляем функцию: сигнатура, определение. Тип процитирован, тело процитировано. В теле есть подстановка <code>comm</code>, которая заменится на соответствующую строку.</p>

<h2>Дополнения</h2>

<p>Дальше я буду усложнять задачу и попытаюсь автоматизировать всё, что можно в HaTeXExtension. Причём то, что я сейчас пишу, я придумал только что ")</p>

<p><em>Операторы-синонимы</em></p>

<p>Я говорил о том, что использую юникодовские символы для обозначения операторов соответствующих TeX'овских команд. Вроде такого:</p>

<p>``` haskell</p>

<pre><code>a ⎕ b = a ◇ space ◇ b
a ≤ b = a ◇ leq ◇ b
</code></pre>

<p>```</p>

<p>Ну и коль скоро мы генерим объявления для <code>space</code> и <code>leq</code>, стоит заодно генерить и объявления этих операторов. Чтобы сделать эту возможность гибкой и опциональной, будем передавать в шаблон список строк с именами операторов, так что можно будет оставить его пустым или наоборот написать несколько вариантов имени - например юникодовский и обычный. Причём оператором в данном случае может быть не только инфиксный оператор из спец-символов - если в этом списке будет буквенное имя, то получится просто функция от двух аргументов с таким именем.</p>

<p>``` haskell</p>

<pre><code>defTeXCommand ::  String
               →  String
               → [String]   -- ^ operator names
               →  Q [Dec]
defTeXCommand  ""  comm ops = defTeXCommand comm comm ops
defTeXCommand name comm ops = sequence $
    [ name ^:: [t| LaTeX |]
    , name ^= body
    ] ++ (concatMap opDec ops)
    where
        body = [| TeXComm comm [] |]
        opDec op = [ op ^:: [t| LaTeX → LaTeX → LaTeX |]
                   , op ^= [| λ a b → a ◇ $body ◇ b |]
                   ]
</code></pre>

<p>```</p>

<p>Разберём изменения в этом шаблоне. Мы обрабатываем список имён операторов функцией <code>opDec</code>, на каждый оператор получается двухэлементный список (сигнатура и определение), поэтому мы применяем <code>concatMap</code>, а не просто <code>map</code>.</p>

<p>В определении оператора есть интересный момент. Я вынес тело определения <code>body</code> отдельно, чтобы использовать его и в декларации <code>name</code>, и в <code>op</code>. По идее стоило бы вставить в конструкцию <code>a ◇ … ◇ b</code> само имя <code>name</code>, но я не знаю, как на него там сослаться и не уверен, что это вообще возможно.</p>

<p>Оператор <code>^=</code> принимает второй аргумент цитату выражения (<code>:: Q Exp</code>), поэтому <code>body</code> там используется как есть. А вот в определении <code>op</code> мы находимся уже внутри цитаты, поэтому там нужно расцитировать <code>body</code> и вклеить - это и есть сплайсинг. Это работает как-то так:</p>

<p>``` haskell</p>

<pre><code>    [| λ a b → a ◇          $body           ◇ b |]
 ~&gt; [| λ a b → a ◇ $([| TeXComm comm [] |]) ◇ b |]
 ~&gt; [| λ a b → a ◇     (TeXComm comm [])    ◇ b |]
</code></pre>

<p>```</p>

<p>Ну и пример для ясности. Положим, основном модуле HaTeXExtension есть такой текст:</p>

<p>``` haskell</p>

<pre><code>import HaTeXExtension.Meta

…

defTeXCommand "leq_" "leq" ["&lt;=:","≤","leq"] 

…
</code></pre>

<p>```</p>

<p>то есть мы определяем "символ" <code>leq_</code>, соответствующий команде <code>\leq</code> в TeX'е и набор операторов-синонимов. Этот шаблон развернётся при компиляции в следующие декларации:</p>

<p>``` haskell</p>

<pre><code>leq_ :: LaTeX
leq_ = TeXComm "leq" []

&lt;=: :: LaTeX → LaTeX → LaTeX
&lt;=: = λ a b → ((a ◇ TeXComm "leq" ) ◇ b)

≤ :: LaTeX → LaTeX → LaTeX
≤ = λ a b → ((a ◇ TeXComm "leq" []) ◇ b)

leq :: LaTeX → LaTeX → LaTeX
leq = λ a b → ((a ◇ TeXComm "leq" []) ◇ b)
</code></pre>

<p>```</p>

<p>Что и требовалось, как говорится. Кстати, если честно, я немного упрощаю вид того, что получается. Дело в том, что при реальном разворачивании шаблона для всех локальных переменных генерируются уникальные идентификаторы, поэтому все эти <code>a</code> и <code>b</code> буду выглядеть как <code>a[a3cm]</code> и <code>b[a3cn]</code>.</p>

<p>Кстати, раз уж я об этом заговорил, поскольку разворачивание шаблонов происходит на стадии компиляции, по-умолчанию вы не увидите, во что они развернулись. Для того, чтобы увидеть, нужно загружая модуль в ghci указать ему опцию <code>-ddump-splices</code> и тогда он по ходу загрузки напишет результаты развёртки всех шаблонов - очень удобно.</p>

<p><strong>UPDATE:</strong>
Я понял, как можно сплайсить имя созданной функции, вместо <code>body</code>:</p>

<p>``` haskell</p>

<pre><code>defTeXCommand name comm ops = sequence $
    [ name ^:: [t| LaTeX |]
    , name ^= [| TeXComm comm [] |]
    ] ++ (concatMap opDec ops)
    where
        opDec op = [ op ^:: [t| LaTeX → LaTeX → LaTeX |]
                   , op ^= [| λ a b → a ◇ $(dyn name) ◇ b |]
                   ]
</code></pre>

<p>```</p>

<p>Тут тело определения осталось там где и было сначала. Теперь чтобы сплайсить имя, нужно сделать из него процитированное выражение то есть <code>Q Exp</code>, содержащее соответствующий идентификатор. Для этого мы делаем "динамическую связку"(dynamic binding) с помощью функции</p>

<p>``` haskell</p>

<pre><code>dyn :: String → Q Exp
dyn name = return (VarE (mkName name))
</code></pre>

<p>```</p>

<p>в документации написано, что она "не гигиеничная". Я подозреваю, что мой подход с подстановкой имён в декларации в принципе не гигиеничный - могут возникнуть конфликты имён. Наверное поэтому это и не сделано по умолчанию. Но я не очень понимаю так ли велика проблема - ведь если буду случайно две функции с одинаковым именем, то ошибка выявится при компиляции..</p>

<p>На сегодня всё. У меня есть ещё дополнения, но что-то я совсем устал, так что напишу о них завтра.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Про HaTeX 3 и юникод в коде]]></title>
    <link href="http://laughedelic.github.com/blog/2011/10/26/hatex-with-unicode/"/>
    <updated>2011-10-26T02:06:00+02:00</updated>
    <id>http://laughedelic.github.com/blog/2011/10/26/hatex-with-unicode</id>
    <content type="html"><![CDATA[<p><em>(репост из <a href="http://laughedelic.tumblr.com/post/11922293522/hatex-3">tumblr</a>)</em></p>

<h2>Вступление</h2>

<p>Давненько я не заглядывал сюда и не писал ничего содержательного.
Но тут в очередной раз есть повод поделиться впечатлениями от новых интересных знаний и к тому же для этого удалось выкроить немного времени.</p>

<p>Итак, я дождался таки выхода в свет 3й версии библиотеки <a href="http://deltadiaz.blogspot.com/2011/10/hatex-3-first-release.html">HaTeX</a> - предыдущая версия была аж год назад. И за этот год я периодически писал автору, интересуясь, не собирается ли он что-нибудь делать, поскольку предыдущая версия была хороша только как концепт, но слишком далека от идеала и малопригодна для реального применения (хотя я ей всё таки пользовался и надеюсь ещё отдельно рассказать как именно). Хотел даже сам переделать её, но как всегда не хватало времени.</p>

<p>Я кстати <a href="http://laughedelic.tumblr.com/post/5312922803">писал в мае</a> о том как и почему мне нравится HaTeX. Так вот <a href="http://deltadiaz.blogspot.com/2011/09/hatex-3-previous-notes.html">пред-релизное известие</a> о новых концепциях в HaTeX-3 очень меня обрадовало. Главный момент (для меня), в том, что теперь есть специальный <a href="http://hackage.haskell.org/packages/archive/HaTeX/3.0.0/doc/html/Text-LaTeX-Base-Syntax.html#t:LaTeX">алгебраический тип <code>LaTeX</code></a>, с помощью которого конструируются LaTeX-выражения на Haskell'е. Такой подход даёт возможность контролировать валидность получаемых (true-)LaTeX-выражений на выходе.</p>

<!-- more -->


<p>На самом деле это тоже не то, что я хотел, когда говорил о типо-безопасном LaTeX'е, но всё же, лучше, чем было раньше. Я вижу это скорее как класс типов, которые можно представить в форме LaTeX'а, но об этом надо ещё подумать (это мне напомнило <a href="http://laughedelic.tumblr.com/post/11917167041">цитату</a>, по ходу дела).</p>

<h2>Немного об изменениях</h2>

<p>Ладно, ближе к делу. Когда я пользовался HaTeX'ом до 3й версии, я написал для себя небольшое дополнение - там были команды, которых мне не хватало и удобные сокращения. Так вот перед тем как начать пользоваться новой версией, я естественно занялся переделкой этих дополнений для совместимости с ней. На самом деле менять почти ничего не пришлось - в основном только уродские сигнатуры типа <code>foo :: Monad m =&gt; LaTeX m</code> заменились на <code>foo :: LaTeX</code>, что конечно же к лучшему.</p>

<p>Насчёт пропажи (а на самом деле опциональности) монад в новом HaTeX стоит прочитать <a href="http://deltadiaz.blogspot.com/2011/10/hatex-3-two-styles.html">пост автора о двух стилях</a>. Он говорит что новый способ, изобилующий операторами <code>&lt;&gt;</code> для склейки частей <code>LaTeX</code>-выражений не шибко приятен для глаза ("Yes, all these operators seem ugly"), но мне это наоборот больше нравится ") Просто я и в старой версии не всегда пользовался <code>do</code>-нотацией (по формуле/фразе на строчку?), а частенько писал что-то типа (от балды что-то напишу сейчас)</p>

<p>``` haskell</p>

<pre><code>math $ forall &gt;&gt; x &gt;&gt; from &gt;&gt; "S" &gt;&gt; comma &gt;&gt; space &gt;&gt; f^:2.:(x) &gt;&gt; leq &lt;&gt; 0
</code></pre>

<p>```</p>

<p>Что на обычном LaTeX'е означает примерно следующее:</p>

<p>``` latex</p>

<pre><code>$\forall x\in S,\quad f^2(x)\leq 0$
</code></pre>

<p>```</p>

<p>Что может быть выглядит короче, но уж на мой вкус совершенно отвратительно.
А в HaTeX3 это запишется так:</p>

<p>``` haskell</p>

<pre><code>math $ forall &lt;&gt; x &lt;&gt; from &lt;&gt; "S" &lt;&gt; comma &lt;&gt; space &lt;&gt; f^:2.:(x) &lt;&gt; leq &lt;&gt; 0
</code></pre>

<p>```</p>

<p>Во-первых так по-моему лучше (читабельнее), а во вторых, поскольку я пользуюсь <a href="http://b4winckler.wordpress.com/2010/08/07/using-the-conceal-vim-feature-with-latex/">conceal-фишкой</a> в Vim'е, то у меня в нормальном режиме <code>&gt;&gt;</code> заменяется на симпатичную кавычку <code>»</code> (то есть одним символом), а для нового оператора я сделал замену <code>&lt;&gt;</code> на <code>◇</code> (юникодовский символ "white diamond").</p>

<p>И это по-моему прекрасно, потому что код выглядит чисто и чудесно и без всяких там "ugly operators".</p>

<h2>Vim conceal</h2>

<p>Про использование юникодовских символов стоит сказать отдельно. Я не очень люблю conceal в Vim'е, потому что меня раздражает то, что в нормальном режиме всё сворачивается в один символ, но при перемещении он воспринимается как свёрнутая последовательность символов, то есть я тупо натыкаюсь на такой символ, жму вправо 10 раз, а курсор не реагирует. Естественно это приводит к проблемам при копировании/вырезании и т.п. Не понимаю, почему так сделано.</p>

<p>Поэтому conceal'у я оставляю маленькие визуальные украшательства, такие как замена  <code>&lt;&gt;</code> на <code>◇</code> или</p>

<p>``` haskell</p>

<pre><code>(\x -&gt; x == 1) :: Num a =&gt; a -&gt; Bool
</code></pre>

<p>```</p>

<p>на</p>

<p>``` haskell</p>

<pre><code>(λx → x ≡ 1) ∷ Num a ⇒ a → Bool
</code></pre>

<p>```</p>

<p>^__^</p>

<h2>Юникодовские символы для операторов</h2>

<p>В остальном же, я использую юникод для операторов в Haskell'е, благо GHC это поддерживает уже давным давно (можно хоть по-русски функции и типы называть).
Я думаю, любой <strike>правовер</strike> годный редактор позволяет ненапряжно писать, используя юникодовские символы. В Vim'е я делаю это используя функцию IMAP из плагина LaTeX-Suite. Аналогичное можно сделать тысячей других способов и уж точно можно сделать в Emacs/Textmate/Vico. Итак, я пишу в <code>.vimrc</code> cледующую строчку:</p>

<pre><code>call IMAP (";&lt;" , "≤" , "haskell")
</code></pre>

<p>И теперь, при наборе кода<code>;,</code> моментально заменяется на <code>≤</code> - это как ввод иероглифов по их фонетическому эквиваленту (пиньинь вроде называется).
<code>;</code> я использую как префикс, чтобы отличить этот иероглиф (макрос? "/) от обычного ввода символов, поскольку <code>;</code> не используется в Haskell'е (нет, не используется).</p>

<p>Теперь вернёмся к моим дополнениям HaTeX'а, которые я кстати назвал HaTeXExtension. Не шибко хорошее название, но другого пока нет. Я определяю там много таких юникодных операторов:</p>

<p>``` haskell</p>

<pre><code> a ≤ b = a &lt;&gt; leq &lt;&gt; b
</code></pre>

<p>```</p>

<p>Согласитесь, выражение слева от знака равно выглядит приятнее, чем то, что справа. Поэтому и пример кода, данный вначале будет выглядеть иначе (повторяю для наглядного сравнения). Было:</p>

<p>``` haskell</p>

<pre><code>math $ forall &lt;&gt; x &lt;&gt; from &lt;&gt; "S" &lt;&gt; comma &lt;&gt; space &lt;&gt; f^:2.:(x) &lt;&gt; leq &lt;&gt; 0
</code></pre>

<p>```</p>

<p>Станет:</p>

<p>``` haskell</p>

<pre><code>math $ forall &lt;&gt; x ∈ "S" ¸⎕ f⁀2⁖(x) ≤ 0
</code></pre>

<p>```</p>

<p>А при переходе в нормальный режим с conceal'ом, так и вообще</p>

<p>``` haskell</p>

<pre><code>math $ ∀ ◇ x ∈ "S" ¸⎕ f⁀2⁖(x) ≤ 0
</code></pre>

<p>```</p>

<p>Что выглядит уже не длиннее чем LaTeX'овский вариант, и намного симпатичнее его.
Более того, эта запись совсем немного отличается от математической записи (если не брать во внимание "двумерность" математического синтаксиса).
Для ясности, дам определения этих операторов:</p>

<p>``` haskell</p>

<pre><code>a ∈ b = a &lt;&gt; from &lt;&gt; b       -- from это \in 
a ≤ b = a &lt;&gt; leq &lt;&gt; b
</code></pre>

<p>```</p>

<p>(другое имя потому что <code>in</code> - ключевое слово в Haskell)</p>

<p>``` haskell</p>

<pre><code>a ¸ b = a &lt;&gt; comma &lt;&gt; b    -- comma это просто ", "
a ⎕ b = a &lt;&gt; space &lt;&gt; b    -- space это \quad
a ¸⎕ b = a ¸ "" ⎕ b        -- а это их комбинация
</code></pre>

<p>```</p>

<p>тут ¸ - это такая красивая арабская загогулинка, похожая на запятую, которую возможно тут особо не разглядишь, но которая у меня в Vim'е с правильным шрифтом отлично смотрится ")</p>

<p>Ну и последний оператор - это как бы "применение функции к аргументам", чтобы писать <code>f.:(x + y)</code> а не <code>f &lt;&gt; "(" &lt;&gt; x + y &lt;&gt; ")"</code> или <code>f &lt;&gt; prn (x+y)</code> (где <code>prn</code> просто окружает аргумент скобочными символами):</p>

<p>``` haskell</p>

<pre><code>(.:) :: LaTeX -&gt; LaTeX -&gt; LaTeX
func .: params = func &lt;&gt; prn params
(⁖) = (.:)     -- просто юникодовский синоним
</code></pre>

<p>```</p>

<h2>Заключение</h2>

<p>Разумеется всё это можно обоснованно покритиковать на тему того, что не всегда удобно набирать эти юникодовские символы и что вообще это никому не нужно, заменять двух-символьный оператор односимвольным, или это можно сделать через conceal чтобы добиться просто визуального эффекта.</p>

<p>Но ящитаю, что это наоборот очень правильно и важно - <em>код должен выглядеть чисто и однородно</em>. И на мой взгляд, эти символы, сокращающие код и зачастую приближающие его к естественной/общепринятой математической нотации, намного меньше нарушают его однородность и прозрачность, чем всякие служебные символы типа слеша в LaTeX'е и этих ужасных фигурных скобочек. И вообще, по-моему нужно расширять синтаксис обычных языков программирования подобным образом - юникод уже никого ведь не удивляет, а если ещё и двумерный синтаксис сделать (как во всяких maple'ах)?....</p>

<p><strong>P.S.</strong> Завтра постараюсь написать пост про то, как я использую Template Haskell в своём HaTeXExtension чтобы "скрэпать свой бойлерплэйт-код" (:
И да, выложу код на гитхаб.</p>
]]></content>
  </entry>
  
</feed>
