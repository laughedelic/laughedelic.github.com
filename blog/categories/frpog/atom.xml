<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: frpog | Laughedelic's Octopress Blog]]></title>
  <link href="http://laughedelic.github.com/blog/categories/frpog/atom.xml" rel="self"/>
  <link href="http://laughedelic.github.com/"/>
  <updated>2013-02-12T02:21:33+01:00</updated>
  <id>http://laughedelic.github.com/</id>
  <author>
    <name><![CDATA[laughedelic]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Подстановка имён в шаблонах объявлений (TH + SYB)]]></title>
    <link href="http://laughedelic.github.com/blog/2011/11/02/name-substitution-in-declarations-th-plus-syb/"/>
    <updated>2011-11-02T02:59:00+01:00</updated>
    <id>http://laughedelic.github.com/blog/2011/11/02/name-substitution-in-declarations-th-plus-syb</id>
    <content type="html"><![CDATA[<p><em>(репост из <a href="http://laughedelic.tumblr.com/post/12217333091/th-syb">tumblr</a>)</em></p>

<p>Всё, пишу последний пост про свои велосипеды. Дальше буду переводить туториалы и делать уже что-нибудь более содержательное. И то, в свободное от учёбы время - надо сконцентрироваться на дипломе..</p>

<p>Итак, напомню, в чём заключается задача. Я писал об этом в <a href="http://laughedelic.github.com/blog/2011/10/27/template-haskell-note/">первом посте о Template Haskell</a> - задача в том, что хочется делать сплайсинг имён в объявлениях. И я предложил вариант ухода от этой проблемы. Но в заключении того поста я сформулировал недостаток того подхода - с помощью оператора <code>(^=)</code> можно объявлять только <em>значения</em>, то есть если нужна функция с несколькими клозами:</p>

<p>``` haskell</p>

<pre><code>foo :: Num a =&gt; a → String
foo x 1 = show (x + 23)
foo x 2 = show (x - 98)
foo x _ = show x ++ "blah-blah"
</code></pre>

<p>```</p>

<p>то чтобы сделать шаблон, нужно будет запихнуть все клозы в цитату тела:</p>

<p>``` haskell</p>

<pre><code>fooTemplate :: String → Int → Int → String → Q [Dec]
fooTemplate name y z blah = sequence
    [ name ^:: [t| Num a =&gt; a → String |]
    , name ^= [| λ a b → case (a,b) of
                  (x,1) → show (x + y)
                  (x,2) → show (x - z)
                  (x,_) → show x ++ blah
              |]
    ] 
</code></pre>

<p>```</p>

<p>Это конечно выглядит так себе. Мне не нравится это ограничение такого подхода. Ещё раз повторюсь, я хочу <strong>чтобы шаблон выглядел максимально похожим на то, что он определяет</strong>.</p>

<p>И я нашёл решение. Даже два:</p>

<ul>
<li> Одно - в лоб, оно не гибкое, не красивое, для него нужно явно пользоваться конструкторами синтаксиса (чего я пытался до этого избежать), но зато простое (в смысле прямолинейное) и в ключе данной локальной задачи вполне подходит.</li>
<li> Второе решение использует крутую технику - Scrap Your Boilerplate (SYB). Для него нужно немного прокачать своё haskell-fu, но это в любом случае стоит того и на самом деле вовсе не так сложно. То есть я на самом деле не постиг пока всех глубин Generic Programming, посредством SYB, но узнал о том, что это такое в принципе и как этим пользоваться в простейших случаях.</li>
</ul>


<p>Я хочу, чтобы мой шаблон выглядел как-то так:</p>

<p>``` haskell</p>

<pre><code>fooTemplate :: String → Int → Int → String → Q [Dec]
fooTemplate name y z blah = ...
    [d| foo :: Num a =&gt; a → a → String
        foo x 1 = show $ x + y
        foo x 2 = show $ x - z
        foo x _ = show x ++ blah
      |]
</code></pre>

<p>```</p>

<p>То есть цитата будет буквально содержать объявление функции с несколькими клозами и будет содержать явные элементы для подстановки: <code>y, z, blah</code>, они стоят в выражении и с ними ничего делать не надо, и есть один "неявный" placeholder (держатель места) - имя функции <code>foo</code>, которое мы хотим заменить на значение параметра <code>name</code>. А вот место, где стоит троеточие - это и будет наше решение, механизм подстановки этого имени.</p>

<!-- more -->


<h2>Скучное решение</h2>

<p>Начнём с простого, но скучного решения, чтобы потом увидеть преимущества продвинутого решения.</p>

<p>Итак, цель - замена имени в декларации. Так и напишем:</p>

<p>``` haskell</p>

<pre><code>substName :: (Name → Name) → (Dec → Dec)
</code></pre>

<p>```</p>

<p>то есть <code>substName</code> (от substitute name) принимает функцию меняющую одни имена на другие, а выдаёт функцию, которая проделывает эту замену внутри деклараций. Как же она выглядит? А выглядит она стрёмно, приготовьтесь:</p>

<p>``` haskell</p>

<pre><code>substName f (SigD    name  typ) = 
             SigD (f name) typ
substName f (FunD    name  clauses) = 
             FunD (f name) clauses
substName f (DataD cxt    name  tyVarBndr con dervs) =
             DataD cxt (f name) tyVarBndr con dervs
substName f (NewtypeD cxt    name  tyVarBndr con dervs) =
             NewtypeD cxt (f name) tyVarBndr con dervs
substName f (TySynD    name  tyVarBndr typ) = 
             TySynD (f name) tyVarBndr typ
substName f (ClassD cxt    name  tyVarBndr funDep dec) = 
             ClassD cxt (f name) tyVarBndr funDep dec
substName _ dec = dec
</code></pre>

<p>```</p>

<p>Устроена эта функция очень просто: она берёт декларацию в виде структуры данных описания синтаксиса (фу), и выдаёт её же, но применив при этом функцию замены имени. Обратите внимание на следующий момент: я написал только несколько вариантов деклараций (сигнатура, объявление функции, структура данных, newtype, синоним типа и класс), для остальных же деклараций срабатывает последний клоз - ничего не меняется.</p>

<p>То есть эта функция не универсальна, причём в двух аспектах:</p>

<ul>
<li> Cрабатывает не для всех деклараций. Это поправимый недостаток - надо просто дописать ещё 8 клозов (см. определение <a href="http://www.haskell.org/ghc/docs/latest/html/libraries/template-haskell-2.6.0.0/Language-Haskell-TH-Syntax.html#t:Dec"><code>Dec</code></a>).</li>
<li> Заменяет имя только на верхнем уровне. Имена могут встречаться глубже - в "теле" декларации.</li>
</ul>


<p>В рамках поставленной задачи, это не важно, потому что мы хотим менять только имя функции в сигнатуре и определении, так что нам бы хватило определения только с первыми двумя клозами и последним. Но всё же.. Вдруг потом нам захочется большего...</p>

<p>Ладно, теперь сделаем нашу <code>f</code> - функцию меняющую имена, так чтобы она брала список пар строк, которые собственно и означают замену первое на второе:</p>

<p>``` haskell</p>

<pre><code>type NamesMap = [(String, String)]

rename :: NamesMap → (Name → Name)
rename namesMap = λ oldName →
    case lookup (show oldName) namesMap of
         Nothing  → oldName
         Just new → mkName new
</code></pre>

<p>```</p>

<p>Функция <code>lookup</code> из <code>Data.List</code> смотрит есть данный элемент в списке пар, в качестве ключа, если есть возвращает соответствующее значение (<code>Just new</code>), из которого мы делаем новое имя (<code>mkName new</code>), если нет - <code>Nothing</code> и мы ничего не заменяем.</p>

<!--
Можно сделать интереснее - например сделать placeholder'ы универсальными, со специальным синтаксисом типа `__foo`, чтобы они заменялись на тот идентификатор из контекста, который стоит после этого `__`. Да, пожалуй, так будет круче - это же самый натуральный сплайсинг!

    spliceName :: Name → Name
    spliceName nam = 
        case (show nam) of 
             ('_':'_':foo) → mkName foo
                   _       → nam

То есть функция берёт имя, делает из него строку, смотрит, есть ли префикс, если есть, то извлекает оставшуюся часть и делает из неё новое имя (`mkName foo`), а если префикса нет, то возвращает то, что было.
-->


<p>Хорошо, словарик мы обеспечим (пока пусть называется <code>namesMap</code>), теперь нужно её как-то применить к нашим процитированным декларациям. Посмотрим на тип комбинации <code>substName</code> и <code>rename namesMap</code>:</p>

<p>``` haskell</p>

<pre><code>substName (rename namesMap) :: Dec → Dec
</code></pre>

<p>```</p>

<p>Так, теперь на тип цитаты: <code>[d| ... |] :: Q [Dec]</code>. Такой же и возвращаемый тип шаблона. То есть нам надо сделать преобразование <code>Dec → Dec</code> внутри <code>Q [Dec]</code>. Чтобы сделать это для <code>[Dec]</code>, достаточно применить <code>map</code>:</p>

<p>``` haskell</p>

<pre><code>map (substName (rename namesMap)) :: [Dec] → [Dec]
</code></pre>

<p>```</p>

<p>А для того чтобы теперь <em>поднять</em> эту функцию ещё на уровень выше - в монаду Q, нужно применить функцию <code>liftM :: Monad m =&gt; (a → b) → (m a → m b)</code>:</p>

<p>``` haskell</p>

<pre><code>(liftM (map (substName (rename namesMap)))) :: Q [Dec] → Q [Dec]
</code></pre>

<p>```</p>

<p>Что и требовалось. На самом деле список - это же тоже монада, так что мы могли бы написать не <code>map</code>, а ещё один <code>liftM</code>, но ладно, не суть.</p>

<p>Ну и всю эту штуковину надо как-то обозначить, убрав попутно лишние скобки:</p>

<p>``` haskell</p>

<pre><code>renameDecs :: NamesMap → Q [Dec] → Q [Dec]
renameDecs namesMap = liftM $ map $ substName $ rename namesMap
</code></pre>

<p>```</p>

<p>Итак, у нас уже есть все требуемые элементы, осталось собрать их воедино:</p>

<p>``` haskell</p>

<pre><code>fooTemplate :: String → Int → Int → String → Q [Dec]
fooTemplate name y z blah = renameDecs [("foo", name)]
    [d| foo :: Num a =&gt; a → a → String
        foo x 1 = show $ x + y
        foo x 2 = show $ x - z
        foo x _ = show x ++ blah
      |]
</code></pre>

<p>```</p>

<p>Вот и весь шаблон. То есть мы действительно только заполнили троеточие, оставив цитату нетронутой и полностью соответствующей виду результата (по модулю подстановок).</p>

<p>По-моему получилось вполне удобно и симпатично. И делать для этого пришлось не так много: <code>substName</code> → <code>rename</code> → <code>renameDecs</code>. Единственное неудобное место в этой цепочке - это громоздкая функция <code>substName</code>.</p>

<h2>Решение с помощью SYB</h2>

<p>Собственно, второе решение и будет отличаться только определением функции <code>substName</code>. Остальное достаточно универсально и просто.</p>

<p>SYB расшифровывается как Scrap Your Boilerplate и это можно перевести как "Выброси свой говнокод", или лучше как в этой презентации: <a href="http://spbhug.folding-maps.org/wiki/Scrap_Your_Boilerplate_%26_Uniplate?action=AttachFile&amp;do=get&amp;target=syb-uniplate.pdf">"Вычистим скучный код"</a> Ивана Тарасова. Она на русском, включает в себя в некотором виде оф. презентацию SYB и рассматривает альтернативу - Uniplate. Так что всем рекомендую.</p>

<p>Смысл функции <code>substName</code> очень простой - мы хотим подействовать функцией <code>f :: Name → Name</code> на все вхождения <code>Name</code> внутри декларации <code>Dec</code>, а вся эта сложная структура типа <code>Dec</code> нас не интересует. Ну вот SYB как раз и позволяет абстрагироваться нам от этой структуры и написать прямо то, что мы хотим:</p>

<p>``` haskell</p>

<pre><code>substName :: (Name → Name) → (Dec → Dec)
substName f = everywhere (mkT f)
</code></pre>

<p>```</p>

<p>Дословно - сделать из <code>f</code> универсальную трансформацию (<code>mkT</code> - "make transformation"), применить её везде (<code>everywhere</code>). Разве не замечательно? Просто чудесно! Тот ужасный, гов<sup>W</sup> скучный код заменился на всего два слова и притом они довольно прозрачно отражают суть происходящего (если хочется понимания того, как это устроено, поможет презентация, на которую я дал ссылку выше).</p>

<p>С таким определением функция <code>substName</code> нам вообще особо не нужна. Можно сразу написать определением <code>renameDecs</code> без неё, заодно избавившись от скобочек:</p>

<p>``` haskell</p>

<pre><code>renameDecs :: NamesMap → Q [Dec] → Q [Dec]
renameDecs namesMap = liftM $ map $ everywhere $ mkT $ rename namesMap
</code></pre>

<p>```</p>

<p>Ну и тут можно заметить, что в этой цепочке <code>map</code> становится лишним - <code>everywhere</code> может абстрагировать преобразование не только до <code>Dec → Dec</code>, но и до <code>[Dec] → [Dec]</code> - за бесплатно:</p>

<p>``` haskell</p>

<pre><code>renameDecs namesMap = liftM $ everywhere $ mkT $ rename namesMap
</code></pre>

<p>```</p>

<p>К сожалению написать это в стиле point-free не получается, из-за специфичных типов <code>everywhere</code> и <code>mkT</code>. Но даже так, это выглядит довольно хорошо. И при всей своей изящности, это решение лишено тех недостатков, о которых я говорил в первом случае.</p>

<p>Второе решение полностью можно посмотреть тут: <a href="http://gist.github.com/1332269">GitHub gist</a>.</p>

<p>Итого, не считая необязательные сигнатуры, это решение в итоге укладывается всего в <em>5 строчек кода</em>. Прекрасно! ^_^</p>

<p>Для частной задачи получилось здорово. Но всё же это велосипед, потому что QuasiQuoting позволяет делать не только такие подстановки, но и любые другие, то есть расцитирование в любом месте, с любым синтаксисом и для любого DSL. Это конечно круто. Но этого, насколько я знаю, для моей задачи из коробки нету и там тоже надо будет что-то сделать/дополнить, что конечно будет круче и универсальнее, но не совсем очевидно. Этим я займусь в следующий раз. По плану, дальше перевод вводного туториала по TH, потом по QQ, а потом уже и новые <strike>велоси</strike> эксперименты с мета-программированием в общем и QQ в частности.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HaTeXExtension @ GitHub]]></title>
    <link href="http://laughedelic.github.com/blog/2011/11/01/hatexextension-at-github/"/>
    <updated>2011-11-01T12:40:00+01:00</updated>
    <id>http://laughedelic.github.com/blog/2011/11/01/hatexextension-at-github</id>
    <content type="html"><![CDATA[<p><em>(репост из <a href="http://laughedelic.tumblr.com/post/12173307363">tumblr</a>)</em></p>

<p>Итак, официальный анонс ")
Теперь у моего прожекта HaTeXExtension есть своя клёвая страничка на github-pages с мажорным адресом.</p>

<p><a href="http://laughedelic.github.com/HaTeXExtension">http://laughedelic.github.com/HaTeXExtension</a></p>

<p>Плюс там онлайн документация, которую я писал пол-ночи "/ Ну и сам код на гитхабе.</p>

<p>Кстати, автор <a href="http://dhelta.net/hprojects/HaTeX/">HaTeX</a> (Daniel Díaz) нашёл мою репу на гитхабе раньше, чем я успел всё доделать. При этом он уже перенёс пару фишек в основную версию и дал на меня ссылку в общий mailing-list. Я довольный же! <code>^__^</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HaTeXExtension + TH: Спаривание операторов ]]></title>
    <link href="http://laughedelic.github.com/blog/2011/10/30/template-haskell-in-hatexextension-2/"/>
    <updated>2011-10-30T02:41:00+01:00</updated>
    <id>http://laughedelic.github.com/blog/2011/10/30/template-haskell-in-hatexextension-2</id>
    <content type="html"><![CDATA[<p><em>(репост из <a href="http://laughedelic.tumblr.com/post/12091298710/hatexextension-th">tumblr</a>)</em></p>

<p>Продолжаю серию дополнений HaTeXExtension с использованием Template Haskell. В этом посте будет пример шаблона с рекурсивным сплайсингом/цитированием.</p>

<p>Кроме отдельных операторов-синонимов, о которых шла речь в предыдущем посте, я определяю иногда их спаренный вариант - это удобно, потому что иногда хочется написать их один за другим, а поотдельности нельзя (каждому из них нужен второй аргумент), а если написать их слитно, то два операторных символа подряд с синтаксической точки зрения - просто новое имя оператора. Вот пример того, что есть сейчас:</p>

<p>``` haskell</p>

<pre><code>a ¸ b = a ◇ comma ◇ b
a ⎕ b = a ◇ space ◇ b
a ¸⎕ b = a ¸ "" ⎕ b
</code></pre>

<p>```</p>

<p>Хорошо, от первых двух деклараций мы избавились изменив шаблон <code>defTeXCommand</code>. Теперь я хочу сделать шаблон, который будет брать пары операторных символов и генерировать объявление их спаренного варианта. Гм, пошёл делать и понял, что можно брать не пары а списки, чтобы можно было сплавлять сколько угодно операторов.</p>

<!-- more -->


<p>(...прошло некоторое время...)</p>

<p>В общем я подумал, потыкался, и не придумал, как сделать этот шаблон, чтобы передавать ему сами операторы, потому что непонятно, как имея лишь функцию, получить её имя.. Подумаю ещё потом, а пока сделаю шаблон, который будет брать имена операторов в виде строк и делать своё не гигиеничное спаривание ")</p>

<p>``` haskell</p>

<pre><code>defFusedOperators :: [String]   -- ^ strings with operator names
                   →  Q [Dec]   -- ^ top-level declaration
defFusedOperators list = sequence
    [ concat ops ^= body ops | ops ← (map words list) ]
    where 
        body, fuse :: [String] → Q Exp
        body ops = [| λ a b → a ◇ $(fuse ops) ◇ b |]

        fuse   []   = [| "" |]
        fuse (x:xs) = [| $(dyn x) "" "" ◇ $(fuse xs) |]
</code></pre>

<p>```</p>

<p>Чтобы не писать <code>[["¸","⎕","≤"], ["¸","…","¸"]]</code>, что практически не читабельно, мы будем писать так: <code>["¸ ⎕ ≤", "¸ … ¸"]</code>, а в шаблоне эти строки просто разбиваются по пробелам на списки отдельных имён.</p>

<p>Итак, разберём это определение. Шаблон берёт такой вот список сгруппированных имён операторов, пробегает по нему и создаёт объявления операторов со склеенными именами (<code>concat ops</code>). Тело каждого такого оператора выглядит как лямбда <code>λ a b → a ◇ $(fuse ops) ◇ b</code>, то есть оператор, берёт два аргумента и вклеивает между ними спаренные операторы.</p>

<p>Самое интересное - это <code>fuse</code>. Она берёт список операторов (строк с их именами), и делает рекурсивную подстановку. Напомню, что <code>dyn x</code> - это процитированный оператор, мы его сплайсим, то есть вклеиваем и даём ему два пустых аргумента (у него ведь тип <code>LaTeX → LaTeX → LaTeX</code>), чтобы получить просто значение типа <code>LaTeX</code>. А дальше мы соединяем (<code>◇</code>) это с вклеенным результатом рекурсивного вызова <code>$(fuse xs)</code>. Когда же операторы заканчиваются, <code>fuse []</code> возвращает процитированную пустую строку (на самом деле это значение <code>TeXEmpty</code>).</p>

<p>Обычная рекурсивная функция, по своей сути ничем не примечательна, но интересно это цитирование и расцитирование, которое делается по ходу дела. Нужно внимательно следить, чтобы не процитировать два раза или не сделать дважды сплайсинг - <strong>баланс сил сохраняй, юный хаскеллер</strong> ")</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Использование Template Haskell в HaTeXExtension]]></title>
    <link href="http://laughedelic.github.com/blog/2011/10/30/template-haskell-in-hatexextension-1/"/>
    <updated>2011-10-30T01:12:00+02:00</updated>
    <id>http://laughedelic.github.com/blog/2011/10/30/template-haskell-in-hatexextension-1</id>
    <content type="html"><![CDATA[<p><em>(репост из <a href="http://laughedelic.tumblr.com/post/12087955995/template-haskell-hatexextension">tumblr</a>)</em></p>

<h2>Вступление</h2>

<p>За последние дни я много экспериментировал с Template Haskell и узнал много интересных вещей. Я по прежнему многое ещё не понимаю, но со многими вопросами я разобрался и хочу об этом тут написать. Сразу оговорюсь, что мои ответы скорее всего являются следствием того, что я не умею пока готовить TH, или я просто изобретаю самокаты.</p>

<p>Итак, на этой неделе я уже написал два поста о <a href="http://laughedelic.github.com/blog/2011/10/26/hatex-with-unicode/">HaTeX-3</a> и <a href="http://laughedelic.github.com/blog/2011/10/27/template-haskell-note/">Template Haskell</a>. В последнем посте я ставил вопрос о генерации объявлений с помощью TH и непонятной мне невозможности замены имени объявляемого объекта в цитированном коде. (Ну и оборот завернул, это у меня после написания эссе по философии)</p>

<p>Сегодня я немного поразбирался с квазицитированием (<a href="http://www.haskell.org/haskellwiki/Quasiquotation">Quasiquotation</a>, далее коротко QQ) - ещё одним расширением Haskell'а, на базе TH. Рекомендую почитать статью по ссылке и разобрать несложный пример - на нём многое становится понятно. Поначалу я недоумевал - ну парсеры, ну с другим синтаксисом, ну и что… Но сегодня я наконец-то осознал в чём истинная сила QQ и обязательно напишу об этом на следующей неделе. У меня уже есть пара идей для реализации с помощью QQ и в том числе для HaTeX.</p>

<h2>Постановка задачи</h2>

<p>Задача на самом деле остаётся та же, что и в предыдущем посте про TH. Только теперь я переформулирую её в контексте моих экспериментов с HaTeX. Поскольку каких-то TeX'овских команд мне не хватало в HaTeX'е, я решил написать для него небольшое дополнение. Итак, в моём модуле HaTeXExtension была куча объявлений вида</p>

<p>``` haskell</p>

<pre><code>space :: LaTeX
space = " \\quad "

leq :: LaTeX
leq = " \\leq "
</code></pre>

<p>```</p>

<p>и т.п. С переходом на новую версию HaTeX'а, я переделал их таким образом:</p>

<p>``` haskell</p>

<pre><code>space :: LaTeX
space = TeXComm "quad" []

leq :: LaTeX
leq = TeXComm "leq" []
</code></pre>

<p>```</p>

<p>Это конечно не бог весть какой код, но когда таких функций 10 или 20, мне он всё же кажется достаточно скучным и я нашёл в этом повод для себя попробовать использовать Template Haskell. То есть я хочу генерировать такие объявления автоматически по имени команды и функции. Так что теперь этот код выглядит у меня следующим образом:</p>

<p>``` haskell</p>

<pre><code>defTeXCommand "space" "quad"

defTeXCommand "" "leq"     -- имя функции и команды одинаковые
</code></pre>

<p>```</p>

<p>Повторюсь, что задача высосана из пальца, но её можно воспринимать как простой пример.</p>

<!-- more -->


<h2>Решение</h2>

<p>Собственно бо'льшую часть моего подхода я описал в предыдущем посте. Сначала я конечно сделал всё вручную, настрадался, а потом уже задумался о том, как это можно улучшить. Шаблоны должны быть в отдельном модуле, таковы правила TH:</p>

<p>``` haskell</p>

<pre><code>module HaTeXExtension.Meta where

…

defTeXCommand :: String   -- ^ function name
               → String   -- ^ TeX command name
               → Q [Dec]  -- ^ top-level declaration
defTeXCommand  ""  comm = defTeXCommand comm comm
defTeXCommand name comm = sequence
    [ name ^:: [t| LaTeX |]
    , name ^= [| TeXComm comm [] |]
    ]
</code></pre>

<p>```</p>

<p>Вроде бы выглядит достаточно просто и понятно. Объявляем функцию: сигнатура, определение. Тип процитирован, тело процитировано. В теле есть подстановка <code>comm</code>, которая заменится на соответствующую строку.</p>

<h2>Дополнения</h2>

<p>Дальше я буду усложнять задачу и попытаюсь автоматизировать всё, что можно в HaTeXExtension. Причём то, что я сейчас пишу, я придумал только что ")</p>

<p><em>Операторы-синонимы</em></p>

<p>Я говорил о том, что использую юникодовские символы для обозначения операторов соответствующих TeX'овских команд. Вроде такого:</p>

<p>``` haskell</p>

<pre><code>a ⎕ b = a ◇ space ◇ b
a ≤ b = a ◇ leq ◇ b
</code></pre>

<p>```</p>

<p>Ну и коль скоро мы генерим объявления для <code>space</code> и <code>leq</code>, стоит заодно генерить и объявления этих операторов. Чтобы сделать эту возможность гибкой и опциональной, будем передавать в шаблон список строк с именами операторов, так что можно будет оставить его пустым или наоборот написать несколько вариантов имени - например юникодовский и обычный. Причём оператором в данном случае может быть не только инфиксный оператор из спец-символов - если в этом списке будет буквенное имя, то получится просто функция от двух аргументов с таким именем.</p>

<p>``` haskell</p>

<pre><code>defTeXCommand ::  String
               →  String
               → [String]   -- ^ operator names
               →  Q [Dec]
defTeXCommand  ""  comm ops = defTeXCommand comm comm ops
defTeXCommand name comm ops = sequence $
    [ name ^:: [t| LaTeX |]
    , name ^= body
    ] ++ (concatMap opDec ops)
    where
        body = [| TeXComm comm [] |]
        opDec op = [ op ^:: [t| LaTeX → LaTeX → LaTeX |]
                   , op ^= [| λ a b → a ◇ $body ◇ b |]
                   ]
</code></pre>

<p>```</p>

<p>Разберём изменения в этом шаблоне. Мы обрабатываем список имён операторов функцией <code>opDec</code>, на каждый оператор получается двухэлементный список (сигнатура и определение), поэтому мы применяем <code>concatMap</code>, а не просто <code>map</code>.</p>

<p>В определении оператора есть интересный момент. Я вынес тело определения <code>body</code> отдельно, чтобы использовать его и в декларации <code>name</code>, и в <code>op</code>. По идее стоило бы вставить в конструкцию <code>a ◇ … ◇ b</code> само имя <code>name</code>, но я не знаю, как на него там сослаться и не уверен, что это вообще возможно.</p>

<p>Оператор <code>^=</code> принимает второй аргумент цитату выражения (<code>:: Q Exp</code>), поэтому <code>body</code> там используется как есть. А вот в определении <code>op</code> мы находимся уже внутри цитаты, поэтому там нужно расцитировать <code>body</code> и вклеить - это и есть сплайсинг. Это работает как-то так:</p>

<p>``` haskell</p>

<pre><code>    [| λ a b → a ◇          $body           ◇ b |]
 ~&gt; [| λ a b → a ◇ $([| TeXComm comm [] |]) ◇ b |]
 ~&gt; [| λ a b → a ◇     (TeXComm comm [])    ◇ b |]
</code></pre>

<p>```</p>

<p>Ну и пример для ясности. Положим, основном модуле HaTeXExtension есть такой текст:</p>

<p>``` haskell</p>

<pre><code>import HaTeXExtension.Meta

…

defTeXCommand "leq_" "leq" ["&lt;=:","≤","leq"] 

…
</code></pre>

<p>```</p>

<p>то есть мы определяем "символ" <code>leq_</code>, соответствующий команде <code>\leq</code> в TeX'е и набор операторов-синонимов. Этот шаблон развернётся при компиляции в следующие декларации:</p>

<p>``` haskell</p>

<pre><code>leq_ :: LaTeX
leq_ = TeXComm "leq" []

&lt;=: :: LaTeX → LaTeX → LaTeX
&lt;=: = λ a b → ((a ◇ TeXComm "leq" ) ◇ b)

≤ :: LaTeX → LaTeX → LaTeX
≤ = λ a b → ((a ◇ TeXComm "leq" []) ◇ b)

leq :: LaTeX → LaTeX → LaTeX
leq = λ a b → ((a ◇ TeXComm "leq" []) ◇ b)
</code></pre>

<p>```</p>

<p>Что и требовалось, как говорится. Кстати, если честно, я немного упрощаю вид того, что получается. Дело в том, что при реальном разворачивании шаблона для всех локальных переменных генерируются уникальные идентификаторы, поэтому все эти <code>a</code> и <code>b</code> буду выглядеть как <code>a[a3cm]</code> и <code>b[a3cn]</code>.</p>

<p>Кстати, раз уж я об этом заговорил, поскольку разворачивание шаблонов происходит на стадии компиляции, по-умолчанию вы не увидите, во что они развернулись. Для того, чтобы увидеть, нужно загружая модуль в ghci указать ему опцию <code>-ddump-splices</code> и тогда он по ходу загрузки напишет результаты развёртки всех шаблонов - очень удобно.</p>

<p><strong>UPDATE:</strong>
Я понял, как можно сплайсить имя созданной функции, вместо <code>body</code>:</p>

<p>``` haskell</p>

<pre><code>defTeXCommand name comm ops = sequence $
    [ name ^:: [t| LaTeX |]
    , name ^= [| TeXComm comm [] |]
    ] ++ (concatMap opDec ops)
    where
        opDec op = [ op ^:: [t| LaTeX → LaTeX → LaTeX |]
                   , op ^= [| λ a b → a ◇ $(dyn name) ◇ b |]
                   ]
</code></pre>

<p>```</p>

<p>Тут тело определения осталось там где и было сначала. Теперь чтобы сплайсить имя, нужно сделать из него процитированное выражение то есть <code>Q Exp</code>, содержащее соответствующий идентификатор. Для этого мы делаем "динамическую связку"(dynamic binding) с помощью функции</p>

<p>``` haskell</p>

<pre><code>dyn :: String → Q Exp
dyn name = return (VarE (mkName name))
</code></pre>

<p>```</p>

<p>в документации написано, что она "не гигиеничная". Я подозреваю, что мой подход с подстановкой имён в декларации в принципе не гигиеничный - могут возникнуть конфликты имён. Наверное поэтому это и не сделано по умолчанию. Но я не очень понимаю так ли велика проблема - ведь если буду случайно две функции с одинаковым именем, то ошибка выявится при компиляции..</p>

<p>На сегодня всё. У меня есть ещё дополнения, но что-то я совсем устал, так что напишу о них завтра.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Заметка о Template Haskell]]></title>
    <link href="http://laughedelic.github.com/blog/2011/10/27/template-haskell-note/"/>
    <updated>2011-10-27T03:05:00+02:00</updated>
    <id>http://laughedelic.github.com/blog/2011/10/27/template-haskell-note</id>
    <content type="html"><![CDATA[<p><em>(репост из <a href="http://laughedelic.tumblr.com/post/11969113478/template-haskell">tumblr</a>)</em></p>

<h2>Вступление</h2>

<p>На развёрнутый пост о своих многочисленных экспериментах с <a href="http://www.haskell.org/haskellwiki/Template_Haskell">Template Haskell</a> (далее коротко TH) у меня сейчас времени нет, но я его обязательно напишу. В планах даже перевод небольшого туториала.</p>

<p>Эта заметка будет с небольшим вопросом. Я понимаю, что Simon P. Jones (автор TH) борется за чистоту и хочет чтобы везде был строгий контроль типов. На эту тему есть хороший пост в блоге GHC: <a href="http://hackage.haskell.org/trac/ghc/blog/Template%20Haskell%20Proposal">New directions for Template Haskell</a>. Я не всё там понял, но главное, понял, что всем ограничениям (и недоработкам) есть свои причины.</p>

<h2>Постановка задачи</h2>

<p>Мне захотелось написать с помощью TH следующую вещь, в сущности, очень простую: хочу генерить функции с данным именем и части тела. Даже ещё проще, пусть функции без параметров - по сути просто значение данного типа (тип заранее известен). Для простоты, пусть у нас есть такой тип:</p>

<p>``` haskell</p>

<pre><code>data Foo = Bar String
</code></pre>

<p>```</p>

<p>И мы хотим генерить функции (не функции конечно, а <em>объявления</em>) вида:</p>

<p>``` haskell</p>

<pre><code>name :: Foo
name = Bar content
</code></pre>

<p>```</p>

<p>где <code>name</code> и <code>content</code> - это заранее неизвестные значения. То есть параметры генератора/шаблона.</p>

<!-- more -->


<p>Ок, в чём моя личная проблема: я хочу как можно меньше строить AST (абстрактное синтаксическое дерево) вручную, с помощью алгебраических типов из TH.Syntax и даже больше, хочу совсем не использовать. А вместо этого я хочу использовать везде, где можно цитирование (Quoting).</p>

<p>Ну вот насмотрелся я на лисповские макросы с их клёвым квазицитированием и не пойму, почему в TH этого нет "/ Да, я знаю, что там есть квазицитирование, но совсем не такое. Да, возможно я не умею его готовить, но буду рад, если кто-то меня научит.</p>

<h2>Немного о TH</h2>

<p>Итак, без всяких квазей, в TH есть оксфордские скобки: <code>[| som quoted haskell code here |]</code> и они бывают 4х типов:</p>

<ul>
<li><code>[e| … |]</code> или <code>[| … |]</code> для выражений (<code>:: Q Exp</code>)</li>
<li><code>[d| … |]</code> для объявлений (<code>:: Q [Dec]</code>)</li>
<li><code>[t| … |]</code> для типов (<code>:: Q Type</code>)</li>
<li><code>[p| … |]</code> для образцов (паттернов) (<code>:: Q Pat</code>)</li>
</ul>


<p>И есть сплайсинг (splicing - не знаю, как нормально перевести) - это операция обратная цитированию: <code>$( … )</code>. Эта конструкция из цитаты получает сам код.</p>

<p>Как-то так например: <code>$( [| \x → x + $( [| 1 |] ) |] )</code> — то же самое, что просто <code>\x → x + 1</code></p>

<h2>Проблема</h2>

<p>То есть вроде как вот тебе, пожалуйста, цитирование+расцитирование = квазицитирование. Ан нет. Проблема в том, что сплайсить можно не везде. В частности на данный момент <em>нельзя сплайсить в образцах и в типах</em>. Это-то мне и непонятно почему. В посте, на который я дал ссылку вначале есть объяснение (всякие там конфликты имён) и есть ссылки на обсуждения того, как это лучше сделать и т.п. То есть вопрос открытый и довольно давно.</p>

<p>А ведь мне для генерации моих объявлений как раз и нужно сплайсить в образец. То есть я не могу просто сделать так:</p>

<p>``` haskell</p>

<pre><code>template :: String → String → Q [Dec]
template name content = let name' = newName name
                        in [d| $name' = Bar content |]
</code></pre>

<p>```</p>

<p>(Тип <code>Q [Dec]</code> значит, что в результате получаются "top-level declarations")
Просто написать [d| name = Bar content |] я тоже не могу. (newName чтобы сделать имя функции из строки (специальный тип <code>Name</code>)).</p>

<p>Но ладно бы было просто какое-то объяснение - нельзя значит нельзя. Меня удивляет другое - это можно сделать, если строить синтаксическое дерево вручную! Показываю как:</p>

<p>``` haskell</p>

<pre><code>template name content = 
    valD (varP (mkName name))
         (normalB (appE (conE 'Bar) 
                        (litE (stringL content)))) 
         []
</code></pre>

<p>```</p>

<p>Это выглядит ужасно! Сравните с естественным квазицитированием с стиле лиспа: <code>[d| $name = Bar $content |]</code>. Небо и земля!</p>

<p>При этом я ещё научился пользоваться клёвыми конструкциями из TH.Lib, а сначала делал, используя только чистый синтаксис TH.Syntax. В общем это ужасно. А хочется цитировать конструкции, чтобы синтаксическое дерево строилось для них автоматически.</p>

<p>К счастью то, что стоит справа от знака <code>=</code> в объявлении - это просто выражение (<code>Exp</code>), поэтому его можно процитировать и сократить немного этот код:</p>

<p>``` haskell</p>

<pre><code>template name content = 
    valD (varP (mkName name))
         (normalB [| Bar cont |]) 
         []
</code></pre>

<p>```</p>

<p>Это уже лучше. Но всё же меня мучает вопрос, <strong>почему подставить имя в такую конструкцию можно, а в цитату нельзя</strong>.</p>

<p>Аналогичные проблемы и у объявления сигнатуры (<code>buz :: Foo</code>), но они решаются так же:</p>

<p>``` haskell</p>

<pre><code>sigD (mkName name) (conT ''Foo)
</code></pre>

<p>```</p>

<p>или</p>

<p>``` haskell</p>

<pre><code>sigD (mkName name) [t| Foo |]
</code></pre>

<p>```</p>

<p>что для более сложного типа было бы намного удобнее.</p>

<h2><strike>Реше</strike> Уход от проблемы</h2>

<p>Итак, мой вопрос озвучен, теперь я напишу, как я решил его для себя. Как видно, для моей задачи совсем обойтись без конструкторов AST не получается. Поэтому я решил просто спрятать их за небольшим синтаксическим сахаром, чтобы при построении других подобных конструкций не вспоминать про все эти ужасные штуки <code>sigD</code>, <code>conT</code> и т.д. и т.п.</p>

<h2>Сахар</h2>

<p>Для сигнатуры всё просто. Я уже показал, как можно цитировать тип. В качестве улучшения, я хочу забыть про <code>mkName</code> - его всё равно всегда приходится делать. Ну и разумеется долой <code>sigD</code> - вместо него мы я хочу оператор, похожий на обычное <code>::</code></p>

<p>``` haskell</p>

<pre><code>(^::) :: String → Q Type → Q Dec 
name ^:: typeQ = sigD (mkName name) typeQ
</code></pre>

<p>```</p>

<p>Пример использования будет чуть дальше. Теперь о декларации самого определения функции. Мы можем цитировать тело, отлично, мы можем снова избавиться от <code>mkName</code> и всяких <code>varP</code>, и снова сделать оператор похожий на то, что он делает:</p>

<p>``` haskell</p>

<pre><code>(^=) :: String → Q Exp → Q Dec
name ^= bodyQ = valD (varP (mkName name)) (normalB bodyQ) []
</code></pre>

<p>```</p>

<p>Замечательно. Определим ещё одну вспомогательную функцию. Она нужна для того, чтобы объединять одиночные декларации <code>Q Dec</code> в список <code>Q [Dec]</code>, поскольку именно в таком виде их нужно потом сплайсить (на top-level'е).</p>

<p>``` haskell</p>

<pre><code>qDecs :: [Q Dec] → Q [Dec]
qDecs = mapM id
</code></pre>

<p>```</p>

<p>Эту штуку мы получили вообще даром. Для справки тип <code>mapM :: Monad m =&gt; (a → m b) → [a] → m [b]</code>, а <code>Q</code> - это кстати монада цитирования (от "Quote").</p>

<p><strong>UPDATE:</strong> что-то я забыл (спасибо eminglorion за напоминание), что есть стандартная функция <code>sequence ::  Monad m =&gt; [m a] → m [a]</code>, которая как раз делает то же самое. Так что дальше я везде исправлю <code>qDecs</code> на <code>sequence</code>.</p>

<p>Итак, генератор, а правильнее сказать шаблон, который я хотел получить с самого начала будет выглядеть так:</p>

<p>``` haskell</p>

<pre><code>defFooFunc name content = sequence
    [ name ^:: [t| Foo |]
    , name ^= [| Bar content |]
    ]
</code></pre>

<p>```</p>

<p>Ура!!! <code>'\(^__^)/'</code>  Симпатично получилось, правда?</p>

<p>Пользоваться таким шаблоном очень просто. Единственное, что сплайсить шаблоны нельзя в том же модуле, где они определены. На это тоже есть причины… Зато топовые объявления можно сплайсить без этого дурацкого $( … ).</p>

<p>Итак, если я где-нибудь в другом модуле напишу</p>

<p>``` haskell</p>

<pre><code>module AnotherModule where

…

defFooFunc "baz" "quux"

…
</code></pre>

<p>```</p>

<p>То при конпеляции эта строчка заменится на</p>

<p>``` haskell</p>

<pre><code>baz :: Foo
baz = Bar "quux"
</code></pre>

<p>```</p>

<p>Собственно, что и требовалось. В моём решении самое главное то, что <em>шаблон выглядит почти также как результат</em> - так и должно быть вообще-то.</p>

<p>Приятным открытием для меня было то, что если перед <code>defFooFunc "baz" "quux"</code> написать комментарий в формате Haddoc (<code>-- | Blah-blah-blah</code>), то он нормально прицепится к сигнатуре и документация сгенерится так же, как при обычном объявлении. Это и естественно, ведь все разворачивания шаблонов происходят при конпеляции.</p>

<h2>Заключение</h2>

<p>Разумеется моё решение, хоть и выглядит симпатично, не является универсальным. Не любую синтаксическу конструкцию определения функции можно так описать. Но тем не  менее, так можно описывать и более сложные функции с несколькими параметрами и клозами. Например вот такое объявление:</p>

<p>``` haskell</p>

<pre><code>foo :: Num a =&gt; a → String
foo x 1 = show (x + 23)
foo x 2 = show (x - 98)
foo x _ = show x ++ "blah-blah"
</code></pre>

<p>```</p>

<p>где имя функции <code>foo</code>, числа <code>23</code>, <code>98</code> и строчка <code>"blah-blah"</code> - подстановочные. Как это делается:</p>

<p>``` haskell</p>

<pre><code>fooTemplate :: Num a =&gt; String → a → a → String → Q [Dec]
fooTemplate name y z blah = sequence
    [ name ^:: [t| Num a =&gt; a → String |]
    , name ^= [| λ a b → case (a,b) of
                  (x,1) → show (x + y)
                  (x,2) → show (x - z)
                  (x,_) → show x ++ blah
              |]
    ] 
</code></pre>

<p>```</p>

<p>Ну и соответственно <code>$(fooTemplate "foo" 23 98 "blah-blah")</code> сплайсится в то определение, которое мы рассматриваем. Нет, ну конечно не в то же самое. Да, там было три клоза, а у в шаблоне один.. Ну и что, функция ведь получилась такая же. Может кто-нибудь знает, почему не такая же - буду рад узнать.</p>

<p>Меня же такой подход расстраивает только тем, что шаблон опять же выглядит не совсем так, как желаемый результат. Эта неудобная конструкция <code>λ a b → case (a,b) of …</code> конечно не радует глаз, но пока у меня нет прямого решения. Я пробовал сделать это напрямую, но пока у меня это не получилось, потому что возникают проблемы с образцами, а процитировать отдельно клоз нельзя.</p>

<p><strong>UPDATE:</strong>
Я решил эту проблему и описал решение в другом <a href="http://laughedelic.github.com/blog/2011/11/02/name-substitution-in-declarations-th-plus-syb/">посте</a>.</p>

<p><strong>P.S.</strong> как-то у меня не получается писать совсем коротко. Пост сначала назывался "Короткая заметка …", но потом я увлёкся и пришлось изменить название. Я хотел написать только коротко о проблеме и моём решении, но без краткого введения в Template Haskell и сопутствующих тем не обошлось. Наверное потому, что мне представляется читатель, который не знает толком этих всех штук и которого надо хотя бы в общем ввести в курс дела. По видимому, это психологическая проекция, ведь обычно, я сам оказываюсь таким несведущим читателем, интересных, но сложных статей…</p>
]]></content>
  </entry>
  
</feed>
