<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: HaTeXExtension | λaughedelic's blog]]></title>
  <link href="http://laughedelic.github.com/blog/categories/hatexextension/atom.xml" rel="self"/>
  <link href="http://laughedelic.github.com/"/>
  <updated>2013-02-13T23:06:21+01:00</updated>
  <id>http://laughedelic.github.com/</id>
  <author>
    <name><![CDATA[laughedelic]]></name>
    <email><![CDATA[laughedelic@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[HaTeXExtension @ GitHub]]></title>
    <link href="http://laughedelic.github.com/blog/2011/11/01/hatexextension-at-github/"/>
    <updated>2011-11-01T12:40:00+01:00</updated>
    <id>http://laughedelic.github.com/blog/2011/11/01/hatexextension-at-github</id>
    <content type="html"><![CDATA[<p><em>(репост из <a href="http://laughedelic.tumblr.com/post/12173307363">tumblr</a>)</em></p>

<p>Итак, официальный анонс ")
Теперь у моего прожекта HaTeXExtension есть своя клёвая страничка на github-pages с мажорным адресом.</p>

<p><a href="http://laughedelic.github.com/HaTeXExtension">http://laughedelic.github.com/HaTeXExtension</a></p>

<p>Плюс там онлайн документация, которую я писал пол-ночи "/ Ну и сам код на гитхабе.</p>

<p>Кстати, автор <a href="http://dhelta.net/hprojects/HaTeX/">HaTeX</a> (Daniel Díaz) нашёл мою репу на гитхабе раньше, чем я успел всё доделать. При этом он уже перенёс пару фишек в основную версию и дал на меня ссылку в общий mailing-list. Я довольный же! <code>^__^</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HaTeXExtension + TH: Спаривание операторов ]]></title>
    <link href="http://laughedelic.github.com/blog/2011/10/30/template-haskell-in-hatexextension-2/"/>
    <updated>2011-10-30T02:41:00+01:00</updated>
    <id>http://laughedelic.github.com/blog/2011/10/30/template-haskell-in-hatexextension-2</id>
    <content type="html"><![CDATA[<p><em>(репост из <a href="http://laughedelic.tumblr.com/post/12091298710/hatexextension-th">tumblr</a>)</em></p>

<p>Продолжаю серию дополнений HaTeXExtension с использованием Template Haskell. В этом посте будет пример шаблона с рекурсивным сплайсингом/цитированием.</p>

<p>Кроме отдельных операторов-синонимов, о которых шла речь в предыдущем посте, я определяю иногда их спаренный вариант - это удобно, потому что иногда хочется написать их один за другим, а поотдельности нельзя (каждому из них нужен второй аргумент), а если написать их слитно, то два операторных символа подряд с синтаксической точки зрения - просто новое имя оператора. Вот пример того, что есть сейчас:</p>

<p>``` haskell</p>

<pre><code>a ¸ b = a ◇ comma ◇ b
a ⎕ b = a ◇ space ◇ b
a ¸⎕ b = a ¸ "" ⎕ b
</code></pre>

<p>```</p>

<p>Хорошо, от первых двух деклараций мы избавились изменив шаблон <code>defTeXCommand</code>. Теперь я хочу сделать шаблон, который будет брать пары операторных символов и генерировать объявление их спаренного варианта. Гм, пошёл делать и понял, что можно брать не пары а списки, чтобы можно было сплавлять сколько угодно операторов.</p>

<!-- more -->


<p>(...прошло некоторое время...)</p>

<p>В общем я подумал, потыкался, и не придумал, как сделать этот шаблон, чтобы передавать ему сами операторы, потому что непонятно, как имея лишь функцию, получить её имя.. Подумаю ещё потом, а пока сделаю шаблон, который будет брать имена операторов в виде строк и делать своё не гигиеничное спаривание ")</p>

<p>``` haskell</p>

<pre><code>defFusedOperators :: [String]   -- ^ strings with operator names
                   →  Q [Dec]   -- ^ top-level declaration
defFusedOperators list = sequence
    [ concat ops ^= body ops | ops ← (map words list) ]
    where 
        body, fuse :: [String] → Q Exp
        body ops = [| λ a b → a ◇ $(fuse ops) ◇ b |]

        fuse   []   = [| "" |]
        fuse (x:xs) = [| $(dyn x) "" "" ◇ $(fuse xs) |]
</code></pre>

<p>```</p>

<p>Чтобы не писать <code>[["¸","⎕","≤"], ["¸","…","¸"]]</code>, что практически не читабельно, мы будем писать так: <code>["¸ ⎕ ≤", "¸ … ¸"]</code>, а в шаблоне эти строки просто разбиваются по пробелам на списки отдельных имён.</p>

<p>Итак, разберём это определение. Шаблон берёт такой вот список сгруппированных имён операторов, пробегает по нему и создаёт объявления операторов со склеенными именами (<code>concat ops</code>). Тело каждого такого оператора выглядит как лямбда <code>λ a b → a ◇ $(fuse ops) ◇ b</code>, то есть оператор, берёт два аргумента и вклеивает между ними спаренные операторы.</p>

<p>Самое интересное - это <code>fuse</code>. Она берёт список операторов (строк с их именами), и делает рекурсивную подстановку. Напомню, что <code>dyn x</code> - это процитированный оператор, мы его сплайсим, то есть вклеиваем и даём ему два пустых аргумента (у него ведь тип <code>LaTeX → LaTeX → LaTeX</code>), чтобы получить просто значение типа <code>LaTeX</code>. А дальше мы соединяем (<code>◇</code>) это с вклеенным результатом рекурсивного вызова <code>$(fuse xs)</code>. Когда же операторы заканчиваются, <code>fuse []</code> возвращает процитированную пустую строку (на самом деле это значение <code>TeXEmpty</code>).</p>

<p>Обычная рекурсивная функция, по своей сути ничем не примечательна, но интересно это цитирование и расцитирование, которое делается по ходу дела. Нужно внимательно следить, чтобы не процитировать два раза или не сделать дважды сплайсинг - <strong>баланс сил сохраняй, юный хаскеллер</strong> ")</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Использование Template Haskell в HaTeXExtension]]></title>
    <link href="http://laughedelic.github.com/blog/2011/10/30/template-haskell-in-hatexextension-1/"/>
    <updated>2011-10-30T01:12:00+02:00</updated>
    <id>http://laughedelic.github.com/blog/2011/10/30/template-haskell-in-hatexextension-1</id>
    <content type="html"><![CDATA[<p><em>(репост из <a href="http://laughedelic.tumblr.com/post/12087955995/template-haskell-hatexextension">tumblr</a>)</em></p>

<h2>Вступление</h2>

<p>За последние дни я много экспериментировал с Template Haskell и узнал много интересных вещей. Я по прежнему многое ещё не понимаю, но со многими вопросами я разобрался и хочу об этом тут написать. Сразу оговорюсь, что мои ответы скорее всего являются следствием того, что я не умею пока готовить TH, или я просто изобретаю самокаты.</p>

<p>Итак, на этой неделе я уже написал два поста о <a href="http://laughedelic.github.com/blog/2011/10/26/hatex-with-unicode/">HaTeX-3</a> и <a href="http://laughedelic.github.com/blog/2011/10/27/template-haskell-note/">Template Haskell</a>. В последнем посте я ставил вопрос о генерации объявлений с помощью TH и непонятной мне невозможности замены имени объявляемого объекта в цитированном коде. (Ну и оборот завернул, это у меня после написания эссе по философии)</p>

<p>Сегодня я немного поразбирался с квазицитированием (<a href="http://www.haskell.org/haskellwiki/Quasiquotation">Quasiquotation</a>, далее коротко QQ) - ещё одним расширением Haskell'а, на базе TH. Рекомендую почитать статью по ссылке и разобрать несложный пример - на нём многое становится понятно. Поначалу я недоумевал - ну парсеры, ну с другим синтаксисом, ну и что… Но сегодня я наконец-то осознал в чём истинная сила QQ и обязательно напишу об этом на следующей неделе. У меня уже есть пара идей для реализации с помощью QQ и в том числе для HaTeX.</p>

<h2>Постановка задачи</h2>

<p>Задача на самом деле остаётся та же, что и в предыдущем посте про TH. Только теперь я переформулирую её в контексте моих экспериментов с HaTeX. Поскольку каких-то TeX'овских команд мне не хватало в HaTeX'е, я решил написать для него небольшое дополнение. Итак, в моём модуле HaTeXExtension была куча объявлений вида</p>

<p>``` haskell</p>

<pre><code>space :: LaTeX
space = " \\quad "

leq :: LaTeX
leq = " \\leq "
</code></pre>

<p>```</p>

<p>и т.п. С переходом на новую версию HaTeX'а, я переделал их таким образом:</p>

<p>``` haskell</p>

<pre><code>space :: LaTeX
space = TeXComm "quad" []

leq :: LaTeX
leq = TeXComm "leq" []
</code></pre>

<p>```</p>

<p>Это конечно не бог весть какой код, но когда таких функций 10 или 20, мне он всё же кажется достаточно скучным и я нашёл в этом повод для себя попробовать использовать Template Haskell. То есть я хочу генерировать такие объявления автоматически по имени команды и функции. Так что теперь этот код выглядит у меня следующим образом:</p>

<p>``` haskell</p>

<pre><code>defTeXCommand "space" "quad"

defTeXCommand "" "leq"     -- имя функции и команды одинаковые
</code></pre>

<p>```</p>

<p>Повторюсь, что задача высосана из пальца, но её можно воспринимать как простой пример.</p>

<!-- more -->


<h2>Решение</h2>

<p>Собственно бо'льшую часть моего подхода я описал в предыдущем посте. Сначала я конечно сделал всё вручную, настрадался, а потом уже задумался о том, как это можно улучшить. Шаблоны должны быть в отдельном модуле, таковы правила TH:</p>

<p>``` haskell</p>

<pre><code>module HaTeXExtension.Meta where

…

defTeXCommand :: String   -- ^ function name
               → String   -- ^ TeX command name
               → Q [Dec]  -- ^ top-level declaration
defTeXCommand  ""  comm = defTeXCommand comm comm
defTeXCommand name comm = sequence
    [ name ^:: [t| LaTeX |]
    , name ^= [| TeXComm comm [] |]
    ]
</code></pre>

<p>```</p>

<p>Вроде бы выглядит достаточно просто и понятно. Объявляем функцию: сигнатура, определение. Тип процитирован, тело процитировано. В теле есть подстановка <code>comm</code>, которая заменится на соответствующую строку.</p>

<h2>Дополнения</h2>

<p>Дальше я буду усложнять задачу и попытаюсь автоматизировать всё, что можно в HaTeXExtension. Причём то, что я сейчас пишу, я придумал только что ")</p>

<p><em>Операторы-синонимы</em></p>

<p>Я говорил о том, что использую юникодовские символы для обозначения операторов соответствующих TeX'овских команд. Вроде такого:</p>

<p>``` haskell</p>

<pre><code>a ⎕ b = a ◇ space ◇ b
a ≤ b = a ◇ leq ◇ b
</code></pre>

<p>```</p>

<p>Ну и коль скоро мы генерим объявления для <code>space</code> и <code>leq</code>, стоит заодно генерить и объявления этих операторов. Чтобы сделать эту возможность гибкой и опциональной, будем передавать в шаблон список строк с именами операторов, так что можно будет оставить его пустым или наоборот написать несколько вариантов имени - например юникодовский и обычный. Причём оператором в данном случае может быть не только инфиксный оператор из спец-символов - если в этом списке будет буквенное имя, то получится просто функция от двух аргументов с таким именем.</p>

<p>``` haskell</p>

<pre><code>defTeXCommand ::  String
               →  String
               → [String]   -- ^ operator names
               →  Q [Dec]
defTeXCommand  ""  comm ops = defTeXCommand comm comm ops
defTeXCommand name comm ops = sequence $
    [ name ^:: [t| LaTeX |]
    , name ^= body
    ] ++ (concatMap opDec ops)
    where
        body = [| TeXComm comm [] |]
        opDec op = [ op ^:: [t| LaTeX → LaTeX → LaTeX |]
                   , op ^= [| λ a b → a ◇ $body ◇ b |]
                   ]
</code></pre>

<p>```</p>

<p>Разберём изменения в этом шаблоне. Мы обрабатываем список имён операторов функцией <code>opDec</code>, на каждый оператор получается двухэлементный список (сигнатура и определение), поэтому мы применяем <code>concatMap</code>, а не просто <code>map</code>.</p>

<p>В определении оператора есть интересный момент. Я вынес тело определения <code>body</code> отдельно, чтобы использовать его и в декларации <code>name</code>, и в <code>op</code>. По идее стоило бы вставить в конструкцию <code>a ◇ … ◇ b</code> само имя <code>name</code>, но я не знаю, как на него там сослаться и не уверен, что это вообще возможно.</p>

<p>Оператор <code>^=</code> принимает второй аргумент цитату выражения (<code>:: Q Exp</code>), поэтому <code>body</code> там используется как есть. А вот в определении <code>op</code> мы находимся уже внутри цитаты, поэтому там нужно расцитировать <code>body</code> и вклеить - это и есть сплайсинг. Это работает как-то так:</p>

<p>``` haskell</p>

<pre><code>    [| λ a b → a ◇          $body           ◇ b |]
 ~&gt; [| λ a b → a ◇ $([| TeXComm comm [] |]) ◇ b |]
 ~&gt; [| λ a b → a ◇     (TeXComm comm [])    ◇ b |]
</code></pre>

<p>```</p>

<p>Ну и пример для ясности. Положим, основном модуле HaTeXExtension есть такой текст:</p>

<p>``` haskell</p>

<pre><code>import HaTeXExtension.Meta

…

defTeXCommand "leq_" "leq" ["&lt;=:","≤","leq"] 

…
</code></pre>

<p>```</p>

<p>то есть мы определяем "символ" <code>leq_</code>, соответствующий команде <code>\leq</code> в TeX'е и набор операторов-синонимов. Этот шаблон развернётся при компиляции в следующие декларации:</p>

<p>``` haskell</p>

<pre><code>leq_ :: LaTeX
leq_ = TeXComm "leq" []

&lt;=: :: LaTeX → LaTeX → LaTeX
&lt;=: = λ a b → ((a ◇ TeXComm "leq" ) ◇ b)

≤ :: LaTeX → LaTeX → LaTeX
≤ = λ a b → ((a ◇ TeXComm "leq" []) ◇ b)

leq :: LaTeX → LaTeX → LaTeX
leq = λ a b → ((a ◇ TeXComm "leq" []) ◇ b)
</code></pre>

<p>```</p>

<p>Что и требовалось, как говорится. Кстати, если честно, я немного упрощаю вид того, что получается. Дело в том, что при реальном разворачивании шаблона для всех локальных переменных генерируются уникальные идентификаторы, поэтому все эти <code>a</code> и <code>b</code> буду выглядеть как <code>a[a3cm]</code> и <code>b[a3cn]</code>.</p>

<p>Кстати, раз уж я об этом заговорил, поскольку разворачивание шаблонов происходит на стадии компиляции, по-умолчанию вы не увидите, во что они развернулись. Для того, чтобы увидеть, нужно загружая модуль в ghci указать ему опцию <code>-ddump-splices</code> и тогда он по ходу загрузки напишет результаты развёртки всех шаблонов - очень удобно.</p>

<p><strong>UPDATE:</strong>
Я понял, как можно сплайсить имя созданной функции, вместо <code>body</code>:</p>

<p>``` haskell</p>

<pre><code>defTeXCommand name comm ops = sequence $
    [ name ^:: [t| LaTeX |]
    , name ^= [| TeXComm comm [] |]
    ] ++ (concatMap opDec ops)
    where
        opDec op = [ op ^:: [t| LaTeX → LaTeX → LaTeX |]
                   , op ^= [| λ a b → a ◇ $(dyn name) ◇ b |]
                   ]
</code></pre>

<p>```</p>

<p>Тут тело определения осталось там где и было сначала. Теперь чтобы сплайсить имя, нужно сделать из него процитированное выражение то есть <code>Q Exp</code>, содержащее соответствующий идентификатор. Для этого мы делаем "динамическую связку"(dynamic binding) с помощью функции</p>

<p>``` haskell</p>

<pre><code>dyn :: String → Q Exp
dyn name = return (VarE (mkName name))
</code></pre>

<p>```</p>

<p>в документации написано, что она "не гигиеничная". Я подозреваю, что мой подход с подстановкой имён в декларации в принципе не гигиеничный - могут возникнуть конфликты имён. Наверное поэтому это и не сделано по умолчанию. Но я не очень понимаю так ли велика проблема - ведь если буду случайно две функции с одинаковым именем, то ошибка выявится при компиляции..</p>

<p>На сегодня всё. У меня есть ещё дополнения, но что-то я совсем устал, так что напишу о них завтра.</p>
]]></content>
  </entry>
  
</feed>
